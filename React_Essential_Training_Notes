________________________________________
ðŸŒ¸ React Essential Training â€“ Notes ðŸŒ¸
________________________________________

ðŸ“˜ 1. JSX â€“ Writing HTML in JavaScript
Concept
JSX = JavaScript + XML. Lets you write HTML-like syntax inside JavaScript. React compiles this into React.createElement.
Example
const element = <h1>Hello, React!</h1>;
Behind the scenes
const element = React.createElement("h1", null, "Hello, React!");
How it works
â€¢	JSX is just syntactic sugar.
â€¢	Must return one parent element (wrap children in <div> or <>).
â€¢	Values inside {} are pure JavaScript.
ðŸ‘‰ Why important? Makes UI code readable and declarative.

________________________________________

ðŸ“˜ 2. Props â€“ Passing Data
Concept
Props = inputs to a component. They make components reusable.
Example
function Greeting({ name }) {
  return <h1>Hello {name}</h1>;
}
<Greeting name="Jinalee" />
How it works
â€¢	Greeting gets props.name = "Jinalee".
â€¢	{name} is replaced with value.
â€¢	Props are immutable â€“ the child cannot change them.
ðŸ‘‰ Why important? Lets you reuse the same component for different data.

________________________________________

ðŸ“˜ 3. State â€“ Memory Inside Components
Concept
State = a componentâ€™s internal memory. Lets UI change without page reload.
Example
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Add</button>
    </>
  );
}
How it works
1.	useState(0) initializes count = 0.
2.	setCount updates state.
3.	Updating triggers a re-render with the new value.
ðŸ‘‰ Why important? Without state, your app is static.

________________________________________

ðŸ“˜ 4. Toggling State
Concept
Common pattern: switch true/false.
Example
const [isOn, setIsOn] = useState(false);

<button onClick={() => setIsOn(!isOn)}>
  {isOn ? "ON" : "OFF"}
</button>
How it works
â€¢	State starts as false.
â€¢	Clicking flips value.
â€¢	React re-renders, showing â€œONâ€ or â€œOFFâ€.
ðŸ‘‰ Why important? Builds interactivity (menus, toggles, dark mode).

________________________________________

ðŸ“˜ 5. useReducer â€“ Complex State
Concept
Alternative to useState. Better for complex updates.
Example
function reducer(state, action) {
  switch (action.type) {
    case "increment": return { count: state.count + 1 };
    case "decrement": return { count: state.count - 1 };
    default: return state;
  }
}
const [state, dispatch] = useReducer(reducer, { count: 0 });
How it works
â€¢	dispatch({type: "increment"}) triggers reducer.
â€¢	Reducer calculates new state.
â€¢	React re-renders with updated data.
ðŸ‘‰ Why important? Keeps logic organized when multiple actions affect state.

________________________________________

ðŸ“˜ 6. useEffect â€“ Handling Side Effects
Concept
Side effects = things outside Reactâ€™s rendering (fetching data, timers, subscriptions).
Example
useEffect(() => {
  console.log("Component mounted");
}, []);
How it works
â€¢	Runs after render.
â€¢	[] = run once on mount.
â€¢	[dependency] = runs again when dependency changes.
ðŸ‘‰ Why important? React only handles rendering; useEffect connects your app to the outside world.

________________________________________

ðŸ“˜ 7. Fetching Data
Concept
Combine useState and useEffect for data fetching.
Example
function Users() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/users")
      .then(res => res.json())
      .then(data => setUsers(data));
  }, []);

  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
How it works
1.	Initial render â†’ empty list.
2.	useEffect runs â†’ fetch data.
3.	Data stored in state.
4.	React re-renders with updated UI.
ðŸ‘‰ Why important? Modern apps almost always fetch from APIs.

________________________________________

ðŸ“˜ 8. Next.js Routing
Concept
File-based routing = every file becomes a page.
Example
pages/about.js â†’ /about
How it works
â€¢	Next scans pages/ directory.
â€¢	Each file = route.
â€¢	Nested folders = nested routes.
ðŸ‘‰ Why important? No need to configure routers manually.

________________________________________

ðŸ“˜ 9. Server vs Client Components
Concept
â€¢	Server Components: Rendered on server, no JS sent to client (fast, SEO-friendly).
â€¢	Client Components: Run in browser, handle events, state, interactivity.
How it works
â€¢	Use server components for heavy data fetching.
â€¢	Use client components for buttons, forms, state.
ðŸ‘‰ Why important? Balances speed and interactivity.

________________________________________

ðŸ“˜ 10. Tailwind CSS â€“ Styling Made Easy
Concept
Utility-first CSS. Apply styles directly as classes.
Example
<div className="bg-pink-200 text-lg p-4 rounded shadow">
  Styled with Tailwind
</div>
How it works
â€¢	Classes are pre-made utilities (bg-pink-200 = background color).
â€¢	Combine small classes to design UI.
ðŸ‘‰ Why important? No writing CSS files, speeds up UI design.

________________________________________

ðŸ“˜ 11. Advanced Next.js
Concepts
â€¢	Caching: Next caches results for faster loads.
â€¢	SSR (Server-Side Rendering): Generate at request â†’ fresh data.
â€¢	SSG (Static Site Generation): Generate at build â†’ fast for static pages.
â€¢	Server Actions: Run form submissions/data logic securely on server.
ðŸ‘‰ Why important? Professional apps rely on these patterns for speed and scalability.

________________________________________

ðŸŒ± Quick Map to Remember
â€¢	Props â†’ External data passed to a component.
â€¢	State â†’ Internal memory of a component.
â€¢	useEffect â†’ Side effects (fetching, timers, APIs).
â€¢	Reducer â†’ Complex state management.
â€¢	Next.js â†’ Routing + server optimizations.
â€¢	Tailwind â†’ Fast, utility-based styling.

________________________________________


